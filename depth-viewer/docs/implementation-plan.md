# Depth Viewer Web版 実装計画

## 📌 このドキュメントについて

これはBTC-USDT板情報をブラウザで表示するWebアプリケーション（https://depth-viewer.vercel.app/）の実装計画書です。
各段階で動作確認を行いながら、確実に機能を積み上げていく開発手法を採用しています。

**重要**: 実装を始める前に、必ずこのドキュメント全体を読んでください。

## 🎯 実装方針

1. **段階的実装**: 6つの段階に分けて、各段階で動作確認を行う
2. **既存資産の活用**: Pythonアプリのデザインと計算ロジックを踏襲
3. **認証なし**: URLを知っていれば誰でも閲覧可能（第1版）
4. **モバイルファースト**: レスポンシブデザインで全デバイス対応
5. **UI配置の原則**: 
   - 現在の市場情報を最上部に配置（価格、板の状態など）
   - タイムフレーム選択をその下に配置
   - グラフをメインコンテンツとして中央に配置
   - 詳細データテーブルを最下部に配置

## 📍 実装の前提条件

**重要**: 実装を開始する前に、以下の前提条件を確認してください：

### データベース環境
- Supabaseプロジェクト「depth」が稼働中
- 以下のテーブルが存在し、データが継続的に追加されている：
  - `order_book_shared` - 5分足データ
  - `order_book_15min` - 15分足データ
  - `order_book_30min` - 30分足データ
  - `order_book_1hour` - 1時間足データ
  - `order_book_2hour` - 2時間足データ
  - `order_book_4hour` - 4時間足データ
  - `order_book_daily` - 日足データ
- 各テーブルには以下のカラムが存在：
  - `id`, `timestamp`, `ask_total`, `bid_total`, `price`, `group_id`
- group_idは「default-group」で統一
- **API制限**: 1リクエストあたり最大1000行まで（無料・有料プラン共通）
- **各時間足での補完可能期間（1000行制限）**:
  - 5分足: 約3.5日分
  - 15分足: 約10.4日分
  - 30分足: 約20.8日分
  - 1時間足: 約41.7日分
  - 2時間足: 約83.3日分
  - 4時間足: 約166.7日分
  - 日足: 約2.7年分

### デスクトップアプリ
- Pythonスクレーパーが5分ごとにデータを収集
- 各時間足のデータを事前集約してアップロード済み
- 詳細は[デスクトップアプリ仕様書](./desktop-app-spec.md)を参照

### 開発環境
- Node.js 18以上がインストール済み
- Vercelアカウントが設定済み
- GitHubリポジトリと連携済み

## 📋 実装段階

### 第1段階：Supabase接続確認 🎯難易度: 15/100

#### 目標
Supabaseに接続し、データが取得できることを確認する。

#### タスク
- Supabase Anon Keyの取得と環境変数設定
- Supabaseクライアントの初期化
- 各テーブルから最新10件のデータ取得
- コンソールにデータを出力

#### 確認項目
```
✅ ユーザーへの確認指示：
「実装が完了しました。以下をチェックしてください：
1. npm run dev でローカルサーバーを起動
2. http://localhost:3000 にアクセス
3. F12キーで開発者コンソールを開く
4. コンソールに以下が表示される：
   - "Supabase connected successfully"
   - 各時間足テーブルからのデータ（5分足、15分足、30分足、1時間足、2時間足、4時間足、日足）
5. エラーが表示されていない

問題なければOKです！」
```

---

### 第2段階：データ取得と表示 🎯難易度: 25/100

#### 目標
選択した時間足のデータを取得し、画面上にテーブル形式で表示する。

#### タスク
- **データ取得の実装**
  - 時間足に応じたテーブルを選択
  - 最新300件のデータを取得（グラフ用）
  - 取得後、データを時系列順（古い→新しい）にソート
- **テーブル表示の実装**
  - テーブルコンポーネントの作成
  - 最新100件のデータをテーブルに表示
  - timestamp、売り板、買い板、価格を表示
  - 買い/売り比率の計算と表示
  - 最終更新時刻の表示

#### 確認項目
```
✅ ユーザーへの確認指示：
「実装が完了しました。以下をチェックしてください：
1. http://localhost:3000 にアクセス
2. ページ上部に現在の情報が表示される：
   - 最新価格（例：$117,721）
   - 売り板総量（例：7,502 BTC）
   - 買い板総量（例：13,945 BTC）
   - 買い/売り比率（例：1.86）
3. テーブルに100行のデータが表示される
4. 各行にtimestamp、ask、bid、priceが表示される
5. タイムスタンプが日本時間で表示される

データが正しく表示されていればOKです！」
```

---

### 第3段階：静的グラフの実装 🎯難易度: 45/100

#### 目標
Chart.jsまたはRechartsを使用して、Pythonアプリと同じ見た目のグラフを表示する。

#### タスク
- グラフライブラリのインストールと設定
- **グラフ表示の実装**
  - 最新300データポイントを表示
  - テーブルは最新100件のまま
- 売り板グラフ（赤色）の実装
  - **Y軸を反転（多いほど下に迫ってくる表現）**
- 買い板グラフ（緑色）の実装
- 2つのグラフを上下に配置
  - **重要：売り板と買い板は別々のグラフ枠として表示**
  - それぞれ独立した背景とグリッドを持つ
  - グラフ間の隙間は最小限に（1-2px程度）
  - グラフ間にタイトルやラベル等のテキスト要素は入れない
  - 各グラフは独立したChart.jsインスタンスとして実装
- 両グラフの縦軸スケールを統一（デスクトップ版と同じ表現）
- X軸（時刻）とY軸（BTC数量）の設定
- グリッド線とダークテーマの適用

#### 確認項目
```
✅ ユーザーへの確認指示：
「実装が完了しました。以下をチェックしてください：
1. http://localhost:3000 にアクセス
2. 画面中央に2つのグラフが表示される：
   - 上段：売り板の推移（赤色の線、下向きに成長）
   - 下段：買い板の推移（緑色の線、上向きに成長）
3. グラフの背景がダーク（#1e1e1e）
4. **売り板グラフと買い板グラフが別々の枠で表示されている**
5. グリッド線が薄く表示される（各グラフで独立）
6. X軸に時刻、Y軸にBTC数量が表示される
7. **両グラフの縦軸の「見た目の変動幅」が同じ**
8. マウスホバーで値が表示される
9. グラフに約300個のデータポイントが表示される
10. Pythonアプリと見た目が似ている

グラフが正しく表示されていればOKです！」
```

---

### 第4段階：タイムフレーム切り替え（時間足） 🎯難易度: 35/100

#### 目標
時間足の切り替え機能を実装し、各時間足のデータを表示できるようにする。

#### タスク
- タイムフレーム選択ボタンの追加
- 5分足、15分足、30分足、1時間足、2時間足、4時間足、日足の選択肢
- **注意**: 1分足と3分足はデスクトップアプリのローカル専用のため、Web版では対象外
- **テーブル選択の実装**
  - 選択した時間足に応じて適切なテーブルから取得
  - 例：1時間足なら`order_book_1hour`テーブル
- グラフの再描画処理
- 選択状態の保持（localStorage使用）
- UI配置の最適化（諸々の情報 → タイムフレーム → グラフ の順序）

#### 確認項目
```
✅ ユーザーへの確認指示：
「実装が完了しました。以下をチェックしてください：
1. http://localhost:3000 にアクセス
2. UIの配置順序が以下になっている：
   - 最新価格などの現在情報（最上部）
   - タイムフレーム選択ボタン（その下）
   - グラフ（その下）
3. 「5分足」を選択：
   - order_book_sharedテーブルからデータ取得
   - 5分ごとのデータポイント
4. 「15分足」を選択：
   - order_book_15minテーブルからデータ取得
   - 15分ごとのデータポイント
5. 「30分足」を選択：
   - order_book_30minテーブルからデータ取得
   - 30分ごとのデータポイント
6. 「1時間足」を選択：
   - order_book_1hourテーブルからデータ取得
   - 1時間ごとのデータポイント
7. 「2時間足」を選択：
   - order_book_2hourテーブルからデータ取得
   - 2時間ごとのデータポイント
8. 「4時間足」を選択：
   - order_book_4hourテーブルからデータ取得
   - 4時間ごとのデータポイント
9. 「日足」を選択：
   - order_book_dailyテーブルからデータ取得
   - 1日ごとのデータポイント
10. ページリロード後も選択が保持される

タイムフレーム切り替えが動作すればOKです！」
```

---

### 第5段階：リアルタイム更新 🎯難易度: 70/100

#### 目標
Supabase RealtimeでWebSocket接続し、データ更新時に自動的にグラフを更新する。

#### タスク
- Supabase Realtime購読の設定
- WebSocket接続の確立
- 新規データ受信時の処理
- グラフへのデータ追加（アニメーション付き）
- 接続状態インジケーターの表示
- 接続エラー時の再接続処理
- メモリリーク対策（古いデータの削除）

#### 確認項目
```
✅ ユーザーへの確認指示：
「実装が完了しました。以下をチェックしてください：
1. http://localhost:3000 にアクセス
2. ページ右上に接続状態が表示される：
   - 緑の●：接続中
   - 黄の●：接続中...
   - 赤の●：切断
3. 5分間ページを開いたままにする
4. 5分後に以下が自動的に起こる：
   - 「データ更新」の通知が表示される
   - グラフに新しいポイントが追加される
   - 最新価格が更新される
   - ページリロードは不要
5. ネットワークを一時切断して再接続：
   - 自動的に再接続される
   - データの欠損がない

リアルタイム更新が動作すればOKです！
※Pythonスクレーパーが動作している必要があります」
```

---

### 第6段階：UI/UXの最適化 🎯難易度: 40/100

#### 目標
ユーザビリティを向上させ、プロフェッショナルな見た目に仕上げる。

#### タスク
- ローディング画面の実装
- エラー画面の実装（データ取得失敗時）
- レスポンシブデザインの調整
- スマートフォン用の縦画面対応
- タブレット用の最適化
- データ更新時のアニメーション追加
- ツールチップの改善
- パフォーマンス最適化

#### 確認項目
```
✅ ユーザーへの確認指示：
「実装が完了しました。以下をチェックしてください：

【デスクトップ】
1. http://localhost:3000 にアクセス
2. 初回ロード時にローディング画面が表示される
3. データ更新時に滑らかなアニメーション
4. 全体的にプロフェッショナルな見た目

【スマートフォン】
5. スマホでアクセス（または開発者ツールでモバイル表示）
6. グラフが画面幅に収まる
7. テキストが読みやすいサイズ
8. スクロールがスムーズ
9. タップ操作が快適

【エラー処理】
10. Supabase接続を切断（環境変数を一時的に変更）
11. エラー画面が表示される
12. 「再試行」ボタンが機能する

【パフォーマンス】
13. Lighthouseスコア90以上
14. 初回表示3秒以内

全ての項目が確認できればOKです！」
```

---

## ⚠️ 実装上の重要な注意事項

### 1. 環境変数の管理
- **NEXT_PUBLIC_SUPABASE_URL**: 必須
- **NEXT_PUBLIC_SUPABASE_ANON_KEY**: 必須
- ローカルは`.env.local`、本番はVercelで設定

### 2. データの扱い
- タイムスタンプはSupabaseにJSTで保存されている（Pythonスクレーパーによる）
- **重要**: タイムスタンプ表示時はタイムゾーン変換を行わない
- group_idは「default-group」でフィルタリング
- 各時間足のデータは事前集約済み（グルーピング不要）

### 3. タイムフレーム（時間足）の設計
- **実装する時間足**: 5分足、15分足、30分足、1時間足、2時間足、4時間足、日足（7種類）
- **除外する時間足**: 1分足と3分足（デスクトップアプリのローカル専用）
- **デフォルト値**: 1時間足（中期的なトレンドを把握しやすい）
- **選択状態の保持**: LocalStorageを使用してユーザーの選択を記憶
- **データ取得方式**: 各時間足の専用テーブルから直接取得
- **グラフ表示仕様**:
  - 全時間足で統一: 最新300データポイント表示
  - データが300未満の場合はすべて表示

### 4. パフォーマンス
- **データ取得戦略**:
  - 初期ロード: 選択中の時間足300本のみ取得
  - 時間足切替: キャッシュがなければ新規取得
  - 300件なら1回のリクエストで取得可能
- **キャッシュ戦略**:
  - 取得済み時間足データはメモリに保持
  - ページリロードでクリア
- **グラフ表示**: 最新300データポイントに制限
- **テーブル表示**: 最新100件に制限
- **目標パフォーマンス**:
  - 初期表示: 1秒以内
  - 時間足切替: キャッシュ時は即座、新規取得時1秒以内

### 5. セキュリティ
- Row Level Security (RLS)は現在無効
- 将来的に認証機能を追加する場合は有効化
- Anon Keyは公開可能（読み取り専用）

## 🔧 実装詳細

### データ取得実装

```javascript
// 時間足に応じたテーブル選択
const getTableName = (timeframe) => {
  const tables = {
    '5min': 'order_book_shared',
    '15min': 'order_book_15min',
    '30min': 'order_book_30min',
    '1hour': 'order_book_1hour',
    '2hour': 'order_book_2hour',
    '4hour': 'order_book_4hour',
    '1day': 'order_book_daily'
  };
  return tables[timeframe];
}

// データ取得
const fetchTimeframeData = async (timeframe, count) => {
  const tableName = getTableName(timeframe);
  const { data, error } = await supabase
    .from(tableName)
    .select('*')
    .eq('group_id', 'default-group')
    .order('timestamp', { ascending: false })
    .limit(count);
    
  if (error) throw error;
  return data;
}
```

### キャッシュ実装

```javascript
// 時間足ごとのデータキャッシュ
const [dataCache, setDataCache] = useState({
  '5min': null,
  '15min': null,
  '30min': null,
  '1hour': null,  // デフォルトで初期ロード
  '2hour': null,
  '4hour': null,
  '1day': null
});

// 時間足切替時の処理
const handleTimeframeChange = async (timeframe) => {
  // キャッシュチェック
  if (dataCache[timeframe]) {
    setDisplayData(dataCache[timeframe]);
    return;
  }
  
  // 新規取得
  const data = await fetchTimeframeData(timeframe, 300);
  setDataCache(prev => ({...prev, [timeframe]: data}));
  setDisplayData(data);
}
```

### リアルタイム更新実装

```javascript
// Realtime購読
useEffect(() => {
  const channel = supabase
    .channel('order-book-changes')
    .on(
      'postgres_changes',
      {
        event: 'INSERT',
        schema: 'public',
        table: getTableName(selectedTimeframe),
        filter: `group_id=eq.default-group`
      },
      (payload) => {
        // 新規データを既存データに追加
        handleNewData(payload.new);
      }
    )
    .subscribe();

  return () => {
    supabase.removeChannel(channel);
  };
}, [selectedTimeframe]);
```

## 📊 テーブル構造

```sql
-- 各テーブル共通の構造
CREATE TABLE order_book_[timeframe] (
  id SERIAL PRIMARY KEY,
  timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
  ask_total NUMERIC NOT NULL,
  bid_total NUMERIC NOT NULL,
  price NUMERIC NOT NULL,
  group_id VARCHAR(50) DEFAULT 'default-group',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE(timestamp, group_id)
);

-- インデックス
CREATE INDEX idx_[timeframe]_timestamp ON order_book_[timeframe](timestamp DESC);
CREATE INDEX idx_[timeframe]_group_id ON order_book_[timeframe](group_id);
```

## 📚 関連ドキュメント

- [Supabase公式ドキュメント](https://supabase.com/docs)
- [Next.js公式ドキュメント](https://nextjs.org/docs)
- [Chart.js公式ドキュメント](https://www.chartjs.org/docs/)
- [Recharts公式ドキュメント](https://recharts.org/)
- [デスクトップアプリ仕様書](./desktop-app-spec.md)

---

**このドキュメントは実装の進捗に応じて更新してください。**